<!DOCTYPE html>
<html>
<head>
    <title>WebView Interface Scanner</title>
    <meta charset="utf-8">
    <style>
        body {
            font-family: Arial, sans-serif;
            padding: 20px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            margin: 0;
        }
        .container {
            max-width: 1200px;
            margin: 0 auto;
            background: rgba(255,255,255,0.1);
            backdrop-filter: blur(10px);
            padding: 30px;
            border-radius: 15px;
            box-shadow: 0 8px 32px rgba(0,0,0,0.3);
        }
        .section {
            background: rgba(255,255,255,0.05);
            padding: 20px;
            margin: 15px 0;
            border-radius: 10px;
            border-left: 4px solid #ff6b6b;
        }
        .success { border-left-color: #51cf66; background: rgba(81,207,102,0.2); }
        .warning { border-left-color: #ffd43b; background: rgba(255,212,59,0.2); }
        .info { border-left-color: #339af0; background: rgba(51,154,240,0.2); }
        .critical { border-left-color: #ff3838; background: rgba(255,56,56,0.2); }
        button {
            background: linear-gradient(45deg, #ff6b6b, #ffd93d);
            color: white;
            border: none;
            padding: 12px 24px;
            border-radius: 25px;
            cursor: pointer;
            font-weight: bold;
            margin: 5px;
            transition: transform 0.2s;
        }
        button:hover { transform: scale(1.05); }
        .code {
            background: rgba(0,0,0,0.4);
            padding: 15px;
            border-radius: 8px;
            font-family: 'Courier New', monospace;
            margin: 10px 0;
            overflow-x: auto;
            font-size: 14px;
            white-space: pre-wrap;
            max-height: 400px;
            overflow-y: auto;
        }
        .interface-item {
            background: rgba(255,255,255,0.1);
            padding: 10px;
            margin: 5px 0;
            border-radius: 5px;
            border-left: 3px solid #51cf66;
        }
        .dangerous { border-left-color: #ff3838; }
        .interesting { border-left-color: #ffd43b; }
        table {
            width: 100%;
            border-collapse: collapse;
            margin: 10px 0;
        }
        th, td {
            border: 1px solid rgba(255,255,255,0.3);
            padding: 8px;
            text-align: left;
        }
        th { background: rgba(255,255,255,0.2); }
        .exploit-potential {
            display: inline-block;
            width: 10px;
            height: 10px;
            border-radius: 50%;
            margin-right: 5px;
        }
        .high { background: #ff3838; }
        .medium { background: #ffd43b; }
        .low { background: #51cf66; }
        .hidden { display: none; }
    </style>
</head>
<body>
    <div class="container">
        <h1>üï∏Ô∏è WebView JavaScript Interface Scanner</h1>
        <p>Discovering available native app interfaces and exploitation opportunities</p>
        
        <div class="section warning">
            <h2>üö® Quick Scan</h2>
            <button onclick="quickScan()">üîç Quick Interface Scan</button>
            <button onclick="deepScan()">üî¨ Deep Environment Scan</button>
            <button onclick="findHiddenAPIs()">üïµÔ∏è Find Hidden APIs</button>
            <button onclick="testCommonInterfaces()">üéØ Test Common Interfaces</button>
            <div id="quickResults"></div>
        </div>

        <div class="section info">
            <h2>üì± WebView Environment Detection</h2>
            <div id="envResults">Click Quick Scan to analyze environment...</div>
        </div>

        <div class="section">
            <h2>üîç JavaScript Interface Discovery</h2>
            <div id="interfaceResults">
                <p>Scanning for available JavaScript interfaces...</p>
            </div>
        </div>

        <div class="section">
            <h2>üé™ Window Object Analysis</h2>
            <div id="windowResults">
                <p>Analyzing window object for app-specific functions...</p>
            </div>
        </div>

        <div class="section critical">
            <h2>üî• Potential Exploits Found</h2>
            <div id="exploitResults">
                <p>Run scans to identify exploitation opportunities...</p>
            </div>
        </div>

        <div class="section">
            <h2>üõ†Ô∏è Manual Testing Console</h2>
            <input type="text" id="testInput" placeholder="Enter interface name to test (e.g., Android, webkit, app)" 
                   style="width: 70%; padding: 10px; margin: 5px;">
            <button onclick="testInterface()">Test Interface</button>
            <div id="manualResults"></div>
        </div>

        <div class="section success">
            <h2>üìã Complete Report</h2>
            <button onclick="generateReport()">üìÑ Generate Full Report</button>
            <div id="fullReport" class="hidden">
                <div class="code" id="reportContent"></div>
            </div>
        </div>
    </div>

    <script>
        let discoveredInterfaces = [];
        let exploitOpportunities = [];
        let scanResults = {};

        function log(message, type = 'info') {
            console.log(message);
            const timestamp = new Date().toLocaleTimeString();
            return '[' + timestamp + '] ' + message;
        }

        function quickScan() {
            const resultsDiv = document.getElementById('quickResults');
            resultsDiv.innerHTML = '<p>üîç Running quick scan...</p>';
            
            let results = '<h3>Quick Scan Results:</h3>';
            let foundCount = 0;
            
            // Common WebView interfaces
            const commonInterfaces = [
                'Android', 'webkit', 'app', 'bridge', 'nativeApp', 'mobile',
                'ctf', 'ctfapp', 'CTF', 'CTFAPP', 'native', 'client',
                'AppInterface', 'NativeBridge', 'WebViewInterface'
            ];
            
            commonInterfaces.forEach(name => {
                if (window[name]) {
                    results += '<div class="interface-item dangerous">üö® <strong>' + name + '</strong> - Available!</div>';
                    discoveredInterfaces.push(name);
                    foundCount++;
                }
            });
            
            // Check for webkit message handlers
            if (window.webkit && window.webkit.messageHandlers) {
                results += '<div class="interface-item dangerous">üö® <strong>webkit.messageHandlers</strong> - Available!</div>';
                const handlers = Object.keys(window.webkit.messageHandlers);
                handlers.forEach(handler => {
                    results += '<div class="interface-item interesting">üì± Handler: <strong>' + handler + '</strong></div>';
                    discoveredInterfaces.push('webkit.messageHandlers.' + handler);
                });
                foundCount += handlers.length;
            }
            
            if (foundCount === 0) {
                results += '<div class="interface-item">‚ùå No common interfaces found in quick scan</div>';
            } else {
                results += '<div class="interface-item success">‚úÖ Found ' + foundCount + ' potential interfaces!</div>';
            }
            
            resultsDiv.innerHTML = results;
            analyzeEnvironment();
        }

        function deepScan() {
            const resultsDiv = document.getElementById('windowResults');
            resultsDiv.innerHTML = '<p>üî¨ Performing deep window object scan...</p>';
            
            let results = '<h3>Window Object Analysis:</h3>';
            let suspiciousProps = [];
            
            // Scan all window properties
            for (let prop in window) {
                try {
                    const value = window[prop];
                    const type = typeof value;
                    
                    // Look for suspicious property names
                    const suspicious = /android|webkit|app|native|bridge|ctf|mobile|client|interface/i.test(prop);
                    
                    if (suspicious) {
                        suspiciousProps.push({
                            name: prop,
                            type: type,
                            value: value,
                            suspicious: true
                        });
                    }
                    
                    // Look for functions that might be app-specific
                    if (type === 'function' && !prop.startsWith('_') && prop.length > 2) {
                        const funcStr = value.toString();
                        if (funcStr.includes('[native code]') || funcStr.length < 50) {
                            suspiciousProps.push({
                                name: prop,
                                type: 'native function',
                                value: funcStr.substring(0, 100),
                                suspicious: false
                            });
                        }
                    }
                    
                    // Look for objects with multiple methods
                    if (type === 'object' && value !== null && value !== window) {
                        const methods = Object.getOwnPropertyNames(value).filter(p => typeof value[p] === 'function');
                        if (methods.length > 2 && methods.length < 20) {
                            suspiciousProps.push({
                                name: prop,
                                type: 'object with ' + methods.length + ' methods',
                                value: methods.join(', '),
                                suspicious: false
                            });
                        }
                    }
                } catch (e) {
                    // Property access failed - might be restricted
                }
            }
            
            // Display results
            suspiciousProps.forEach(prop => {
                const className = prop.suspicious ? 'dangerous' : 'interesting';
                const icon = prop.suspicious ? 'üö®' : 'üîç';
                results += '<div class="interface-item ' + className + '">' + icon + ' <strong>' + prop.name + '</strong> (' + prop.type + ')<br>';
                results += '<small>' + (prop.value || '').toString().substring(0, 200) + '</small></div>';
            });
            
            if (suspiciousProps.length === 0) {
                results += '<div class="interface-item">‚ùå No suspicious properties found</div>';
            }
            
            resultsDiv.innerHTML = results;
            scanResults.windowScan = suspiciousProps;
        }

        function findHiddenAPIs() {
            const resultsDiv = document.getElementById('interfaceResults');
            resultsDiv.innerHTML = '<p>üïµÔ∏è Searching for hidden APIs...</p>';
            
            let results = '<h3>Hidden API Discovery:</h3>';
            let found = [];
            
            // Common hidden interface patterns
            const patterns = [
                'window._', 'window.__', 'window.$',
                'document._', 'navigator._',
                'console._', 'location._'
            ];
            
            patterns.forEach(pattern => {
                try {
                    const parts = pattern.split('.');
                    let obj = window;
                    for (let i = 1; i < parts.length - 1; i++) {
                        obj = obj[parts[i]];
                        if (!obj) break;
                    }
                    
                    if (obj) {
                        const props = Object.getOwnPropertyNames(obj).filter(p => p.startsWith('_'));
                        props.forEach(prop => {
                            if (obj[prop] && typeof obj[prop] === 'function') {
                                found.push(pattern.replace('_', prop));
                                results += '<div class="interface-item interesting">üîç Hidden function: <strong>' + pattern.replace('_', prop) + '</strong></div>';
                            }
                        });
                    }
                } catch (e) {}
            });
            
            // Check for prototype pollution/extensions
            const prototypes = [HTMLElement, Document, Window, Navigator];
            prototypes.forEach(proto => {
                const props = Object.getOwnPropertyNames(proto.prototype);
                props.forEach(prop => {
                    if (/app|native|bridge|ctf/i.test(prop)) {
                        found.push(proto.name + '.prototype.' + prop);
                        results += '<div class="interface-item dangerous">üö® Extended prototype: <strong>' + proto.name + '.' + prop + '</strong></div>';
                    }
                });
            });
            
            if (found.length === 0) {
                results += '<div class="interface-item">‚ùå No hidden APIs discovered</div>';
            }
            
            resultsDiv.innerHTML = results;
            scanResults.hiddenAPIs = found;
        }

        function testCommonInterfaces() {
            const resultsDiv = document.getElementById('exploitResults');
            resultsDiv.innerHTML = '<p>üéØ Testing common WebView interfaces...</p>';
            
            let results = '<h3>Interface Testing Results:</h3>';
            let vulnerabilities = [];
            
            // Test Android WebView interfaces
            if (window.Android) {
                results += '<div class="interface-item critical">üî• <strong>Android interface found!</strong></div>';
                
                // Test common Android methods
                const androidMethods = ['openApp', 'getDeviceInfo', 'makeCall', 'sendSMS', 'getLocation', 'openURL', 'showToast'];
                androidMethods.forEach(method => {
                    if (typeof window.Android[method] === 'function') {
                        vulnerabilities.push('Android.' + method + '() - Potential app control');
                        results += '<div class="interface-item dangerous">üö® <strong>Android.' + method + '</strong> - Available!</div>';
                    }
                });
            }
            
            // Test WebKit message handlers
            if (window.webkit && window.webkit.messageHandlers) {
                Object.keys(window.webkit.messageHandlers).forEach(handler => {
                    results += '<div class="interface-item critical">üî• <strong>webkit.messageHandlers.' + handler + '</strong></div>';
                    vulnerabilities.push('webkit.messageHandlers.' + handler + ' - Message passing to native app');
                    
                    // Try to call it
                    try {
                        window.webkit.messageHandlers[handler].postMessage('test');
                        results += '<div class="interface-item dangerous">‚úÖ Successfully called ' + handler + '</div>';
                    } catch (e) {
                        results += '<div class="interface-item warning">‚ö†Ô∏è ' + handler + ' callable but requires specific format</div>';
                    }
                });
            }
            
            // Test for custom app interfaces
            const customTests = ['ctfapp', 'CTFApp', 'app', 'nativeApp', 'bridge'];
            customTests.forEach(name => {
                if (window[name]) {
                    results += '<div class="interface-item critical">üî• <strong>' + name + ' interface found!</strong></div>';
                    
                    // Enumerate methods
                    const methods = Object.getOwnPropertyNames(window[name]).filter(p => typeof window[name][p] === 'function');
                    methods.forEach(method => {
                        vulnerabilities.push(name + '.' + method + '() - Custom app function');
                        results += '<div class="interface-item dangerous">üö® Method: <strong>' + name + '.' + method + '</strong></div>';
                    });
                }
            });
            
            exploitOpportunities = vulnerabilities;
            
            if (vulnerabilities.length === 0) {
                results += '<div class="interface-item">‚úÖ No obvious vulnerabilities found</div>';
            } else {
                results += '<div class="interface-item critical">üö® <strong>' + vulnerabilities.length + ' potential vulnerabilities discovered!</strong></div>';
            }
            
            resultsDiv.innerHTML = results;
        }

        function testInterface() {
            const interfaceName = document.getElementById('testInput').value.trim();
            const resultsDiv = document.getElementById('manualResults');
            
            if (!interfaceName) {
                resultsDiv.innerHTML = '<div class="interface-item warning">‚ö†Ô∏è Please enter an interface name</div>';
                return;
            }
            
            let results = '<h3>Testing: ' + interfaceName + '</h3>';
            
            try {
                // Try to access the interface
                const parts = interfaceName.split('.');
                let obj = window;
                
                for (let part of parts) {
                    obj = obj[part];
                    if (obj === undefined) {
                        results += '<div class="interface-item warning">‚ùå ' + interfaceName + ' not found</div>';
                        resultsDiv.innerHTML = results;
                        return;
                    }
                }
                
                results += '<div class="interface-item success">‚úÖ ' + interfaceName + ' exists!</div>';
                results += '<div class="interface-item info">Type: ' + typeof obj + '</div>';
                
                if (typeof obj === 'function') {
                    results += '<div class="interface-item">Function signature: <code>' + obj.toString().substring(0, 200) + '</code></div>';
                } else if (typeof obj === 'object' && obj !== null) {
                    const props = Object.getOwnPropertyNames(obj);
                    results += '<div class="interface-item">Properties/Methods: ' + props.join(', ') + '</div>';
                    
                    // Test each method
                    props.forEach(prop => {
                        if (typeof obj[prop] === 'function') {
                            results += '<div class="interface-item interesting">üîç Method: <strong>' + prop + '</strong></div>';
                        }
                    });
                }
                
            } catch (error) {
                results += '<div class="interface-item warning">‚ö†Ô∏è Error accessing ' + interfaceName + ': ' + error.message + '</div>';
            }
            
            resultsDiv.innerHTML = results;
        }

        function analyzeEnvironment() {
            const resultsDiv = document.getElementById('envResults');
            
            let analysis = '<h3>Environment Analysis:</h3>';
            analysis += '<table>';
            analysis += '<tr><th>Property</th><th>Value</th><th>Risk Level</th></tr>';
            
            const checks = [
                {
                    name: 'User Agent',
                    value: navigator.userAgent,
                    risk: /WebView|wv/.test(navigator.userAgent) ? 'high' : 'low'
                },
                {
                    name: 'Platform',
                    value: navigator.platform,
                    risk: 'low'
                },
                {
                    name: 'App Context',
                    value: window.Android ? 'Android App' : (window.webkit ? 'iOS App' : 'Browser'),
                    risk: (window.Android || window.webkit) ? 'high' : 'low'
                },
                {
                    name: 'JavaScript Enabled',
                    value: 'Yes',
                    risk: 'medium'
                },
                {
                    name: 'Local Storage',
                    value: typeof localStorage !== 'undefined' ? 'Available' : 'Blocked',
                    risk: 'medium'
                },
                {
                    name: 'Geolocation',
                    value: typeof navigator.geolocation !== 'undefined' ? 'Available' : 'Blocked',
                    risk: 'medium'
                },
                {
                    name: 'Camera/Media',
                    value: typeof navigator.mediaDevices !== 'undefined' ? 'Available' : 'Blocked',
                    risk: 'high'
                }
            ];
            
            checks.forEach(check => {
                analysis += '<tr>';
                analysis += '<td>' + check.name + '</td>';
                analysis += '<td>' + check.value + '</td>';
                analysis += '<td><span class="exploit-potential ' + check.risk + '"></span>' + check.risk.toUpperCase() + '</td>';
                analysis += '</tr>';
            });
            
            analysis += '</table>';
            resultsDiv.innerHTML = analysis;
        }

        function generateReport() {
            const reportDiv = document.getElementById('fullReport');
            const reportContent = document.getElementById('reportContent');
            
            let report = 'WEBVIEW JAVASCRIPT INTERFACE PENETRATION TEST REPORT\n';
            report += '=' * 60 + '\n\n';
            report += 'Timestamp: ' + new Date().toISOString() + '\n';
            report += 'Target: ' + window.location.href + '\n';
            report += 'User Agent: ' + navigator.userAgent + '\n\n';
            
            report += 'DISCOVERED INTERFACES:\n';
            report += '-' * 30 + '\n';
            if (discoveredInterfaces.length > 0) {
                discoveredInterfaces.forEach(interface => {
                    report += '- ' + interface + '\n';
                });
            } else {
                report += 'No interfaces discovered\n';
            }
            
            report += '\nPOTENTIAL EXPLOITS:\n';
            report += '-' * 30 + '\n';
            if (exploitOpportunities.length > 0) {
                exploitOpportunities.forEach(exploit => {
                    report += '- ' + exploit + '\n';
                });
            } else {
                report += 'No obvious exploits found\n';
            }
            
            report += '\nRECOMMENDATIONS:\n';
            report += '-' * 30 + '\n';
            report += '1. Test each discovered interface for unauthorized access\n';
            report += '2. Attempt to call discovered methods with various parameters\n';
            report += '3. Look for information disclosure through interface responses\n';
            report += '4. Test for privilege escalation through native functions\n';
            report += '5. Check if interfaces can access device capabilities\n';
            
            reportContent.textContent = report;
            reportDiv.classList.remove('hidden');
        }

        // Auto-run basic scans on load
        window.onload = function() {
            log('WebView Interface Scanner loaded');
            setTimeout(quickScan, 1000);
            setTimeout(deepScan, 2000);
            setTimeout(findHiddenAPIs, 3000);
            setTimeout(testCommonInterfaces, 4000);
        };
    </script>
</body>
</html>

